package com.samsung.sra.DataStore;

import org.nustaq.serialization.FSTConfiguration;
import org.rocksdb.Options;
import org.rocksdb.RocksDB;
import org.rocksdb.RocksDBException;

import java.nio.ByteBuffer;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Stores all elements explicitly enumerated.
 */
public class EnumeratedStore implements DataStore {
    private RocksDB rocksDB;
    private Options rocksDBOptions;
    private final ConcurrentHashMap<StreamID, Integer> streamCounts;
    private final Map<StreamID, Object> streamSyncObjects;

    private final static byte[] streamCountsSpecialKey = {0};

    private void persistStreamCounts() throws RocksDBException {
        rocksDB.put(streamCountsSpecialKey, fstConf.asByteArray(streamCounts));
    }

    public EnumeratedStore(String rocksDBPath) throws RocksDBException {
        rocksDBOptions = new Options().setCreateIfMissing(true);
        rocksDB = RocksDB.open(rocksDBOptions, rocksDBPath);

        byte[] streamCountsBytes = rocksDB.get(streamCountsSpecialKey);
        if (streamCountsBytes != null) {
            streamCounts = (ConcurrentHashMap<StreamID, Integer>)fstConf.asObject(streamCountsBytes);
            streamSyncObjects = new HashMap<StreamID, Object>();
            for (StreamID streamID: streamCounts.keySet()) {
                streamSyncObjects.put(streamID, new Object());
            }
        } else {
            streamCounts = new ConcurrentHashMap<StreamID, Integer>();
            streamSyncObjects = new HashMap<StreamID, Object>();
        }
    }

    private static final FSTConfiguration fstConf;

    static {
        fstConf = FSTConfiguration.createDefaultConfiguration();

        RocksDB.loadLibrary();
    }

    public void registerStream(StreamID streamID) throws StreamException, RocksDBException {
        synchronized (streamCounts) {
            if (streamCounts.containsKey(streamID)) {
                throw new StreamException("attempting to register stream " + streamID + " twice");
            } else {
                streamCounts.put(streamID, 0);
                streamSyncObjects.put(streamID, new Object());
                persistStreamCounts();
            }
        }
    }

    private byte[] getRocksKey(StreamID streamID, Timestamp t) {
        ByteBuffer bytebuf = ByteBuffer.allocate(StreamID.byteCount + Timestamp.byteCount);
        streamID.writeToByteBuffer(bytebuf);
        t.writeToByteBuffer(bytebuf);
        bytebuf.flip();
        return bytebuf.array();
    }

    private int rocksGet(StreamID streamID, Timestamp t) throws RocksDBException {
        byte[] bytes = rocksDB.get(getRocksKey(streamID, t));
        ByteBuffer bytebuf = ByteBuffer.allocate(4);
        bytebuf.put(bytes);
        bytebuf.flip();
        return bytebuf.getInt();
    }

    private void rocksPut(StreamID streamID, Timestamp t, int value) throws RocksDBException {
        ByteBuffer bytebuf = ByteBuffer.allocate(4);
        bytebuf.putInt(value);
        bytebuf.flip();
        rocksDB.put(getRocksKey(streamID, t), bytebuf.array());
    }

    public Object query(StreamID streamID,
                        Timestamp t0, Timestamp t1, Bucket.QueryType queryType, Object[] queryParams)
            throws StreamException, QueryException, RocksDBException {
        if (t0.compareTo(t1) < 0 || t0.compareTo(t1) > 0) {
            throw new QueryException("[" + t0 + ", " + t1 + "] is not a valid time interval");
        }
        Object syncobj;
        synchronized (streamCounts) {
            if (!streamCounts.containsKey(streamID)) {
                throw new StreamException("querying invalid stream " + streamID);
            }
            syncobj = streamSyncObjects.get(streamID);
        }
        int ret = 0;
        synchronized (syncobj) {
            if (t1 >= streamCounts.get(streamID)) {
                throw new QueryException("[" + t0 + ", " + t1 + "] is not a valid time interval");
            }
            for (int t = t0; t <= t1; ++t) {
                int v = rocksGet(streamID, t);
                switch (queryType) {
                    case COUNT:
                        ret += 1;
                        break;
                    case SUM:
                        ret += v;
                        break;
                    default:
                        throw new QueryException(("invalid query type " + queryType));
                }
            }
        }
        return ret;
    }

    public void append(StreamID streamID, Timestamp ts, Object value, boolean landmarkStartsHere, boolean landmarkEndsHere)
            throws StreamException, LandmarkEventException, RocksDBException {
        Object syncobj;
        synchronized (streamCounts) {
            if (!streamSyncObjects.containsKey(streamID)) {
                throw new StreamException("querying invalid stream " + streamID);
            }
            syncobj = streamSyncObjects.get(streamID);
        }
        synchronized (syncobj) {
            int t0 = streamCounts.get(streamID);
            rocksPut(streamID, t0, (Integer) value);
            streamCounts.put(streamID, t0 + 1);
        }
        synchronized (streamCounts) {
            persistStreamCounts();
        }
    }

    public void close() {
        // FIXME: should wait for any processing appends to terminate first
        if (rocksDB != null) {
            rocksDB.close();
        }
        rocksDBOptions.dispose();
    }

    public long getStoreSizeInBytes() {
        // TODO: synchronize
        long ret = 0;
        for (Integer count: streamCounts.values()) {
            // 12 = 3 ints, viz (streamID, time, value)
            ret += count * 12;
        }
        return ret;
    }

    public static void main(String[] args) {
        DataStore store = null;
        try {
            String storeLoc = "/tmp/tdstore";
            // FIXME: add a deleteStream/resetDatabase operation
            Runtime.getRuntime().exec(new String[]{"rm", "-rf", storeLoc}).waitFor();
            store = new EnumeratedStore(storeLoc);
            StreamID streamID = new StreamID(0);
            store.registerStream(streamID);
            for (int i = 0; i < 10; ++i) {
                boolean landmarkStartsHere = false, landmarkEndsHere = false;
                if (i == 4) landmarkStartsHere = true;
                if (i == 6) landmarkEndsHere = true;
                store.append(streamID, new Timestamp(i), i + 1, landmarkStartsHere, landmarkEndsHere);
            }
            Timestamp t0 = new Timestamp(0), t1 = new Timestamp(9);
            System.out.println(
                    "sum[" + t0 + ", " + t1 + "] = " + store.query(streamID, t0, t1, Bucket.QueryType.SUM, null) + "; " +
                            "count[" + t0 + ", " + t1 + "] = " + store.query(streamID, t0, t1, Bucket.QueryType.COUNT, null));
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (store != null) {
                store.close();
            }
        }
    }
}
